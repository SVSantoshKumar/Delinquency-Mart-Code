CREATE OR REPLACE PROCEDURE DISHA_MART_ANALYTICS.COLLECTION_MART.LOAD_DELIQUENCY_MART()
RETURNS VARCHAR(4000)
LANGUAGE SQL
EXECUTE AS OWNER
AS DECLARE
    -- Logging Variables
    TOTAL_ROWS_IN_PREFINAL INTEGER;
    ROWS_INSERTED INTEGER DEFAULT 0;
    ROWS_UPDATED INTEGER DEFAULT 0;
    ROWS_UNCHANGED INTEGER DEFAULT 0;
    DUPLICATE_COUNT INTEGER;
    DUPLICATE_DETAILS VARCHAR(2000);
    CURR_TIME TIMESTAMP := CURRENT_TIMESTAMP();
    ERROR_MESSAGE VARCHAR(1000);
    FINAL_OUTPUT VARCHAR(4000);
BEGIN
	-- STEP 1: DELETE EXISTING DATA FOR CURRENT DATE TO AVOID DUPLICATES
	CREATE TABLE IF NOT EXISTS DISHA_MART_ANALYTICS.COLLECTION_MART.LOAD_DELIQUENCY_MART() CLUSTER BY (DAILY_DATE)(
LOAN_NO VARCHAR(255)
LOAN_BRANCH VARCHAR(255),
SCHEME VARCHAR(255),
CUSTOMER_ID VARCHAR(255),
UNIQUE_CUSTOMER INTEGER,
UNIQUE_CUSTOMER_FLAG_BUCKET VARCHAR(255),
CUSTOMER_NAME VARCHAR(255),
TOTAL_NO_OF_INSTALLMENT INTEGER, -- Tenure Month
MORATORIUM INTEGER,
TOTAL_BILLED_INSTALLMENT_NO FLOAT,
TOTAL_RECEIV_INSTALLMENT FLOAT,
REMAINING_TENURE FLOAT,
OVERDUE_INSTALLMENT_COUNT FLOAT, -- no_of_od_emi
OVERDUE_PRE_EMI_COUNT FLOAT,
TOTAL_DUE FLOAT,
LPP FLOAT,
PRE_EMI FLOAT,
CBC_DUE FLOAT,
OTHER_CHARGES_DUE FLOAT,
PENAL_AMOUNT_OUTSTANDING FLOAT,
TOTAL_POS FLOAT,
CR FLOAT,
DPD INTEGER,
OP_DPD VARCHAR(255),
COLLX_BKT VARCHAR(255),
BUCKET_HEAD VARCHAR(255),
CYCLE VARCHAR(255),
CURRENT_DPD_SCALE VARCHAR(255),
OP_DPD_SCALE VARCHAR(255),
CURRENT_STATUS VARCHAR(255),
RF_CASES VARCHAR(255),
CURRENT_MONTH_INSTALLMENT FLOAT,
CURRENT_MONTH_INSTALLMENT_DUE_DATE DATE,
LOAN_AMOUNT FLOAT, -- Same as SANCTION_AMOUNT
LAST_RECEIVED_DATE DATE,
LAST_RECEIPT_AMOUNT FLOAT,
BOOKING_DATE DATE,
FIRST_EMI_DATE DATE,
LAST_EMI_DATE DATE,
CYCLE_DATE INTEGER,
REPO_FLAG VARCHAR(255),
OVERDUE_PRINCIPAL FLOAT,
OVERDUE_INTEREST FLOAT,
EMI_PATTERN VARCHAR(255),
BOOKING_DATE DATE,
CHEQUE_IN_TRANSIT_AMT FLOAT,
CHEQUE_IN_TRANSIT_COUNT FLOAT,
DISBURSAL_STATUS VARCHAR(255),
LOAN_STATUS VARCHAR(255),
LOAN_PRODUCT VARCHAR(255),
LOAN_EFFECTIVE_RATE FLOAT,
EMI_PEMI VARCHAR(255),
FILE_EXTRACT_DATE DATE,
BUSINESS_DATE DATE,
INSTALLMENT_MODE VARCHAR(255),
LOAN_SANCTION_DATE DATE,
LAST_DISBURMENT_DATE DATE,
BALANCE_TENURE_MONTH INTEGER,
NET_LTV INTEGER,
NPA_STAGEID INTEGER,
EMI_FREQUENCY VARCHAR(255),
EMI_AMOUNT FLOAT
EMI_OVERDUE_AMOUNT  FLOAT,
EXCESS_BALANCE FLOAT,
FUTURE_PRINCIPAL FLOAT,
ROID INTEGER, -- need to join with hierarchy
RO_NAME  VARCHAR(255),-- need to join with hierarchy
NEXT_EMI_AMOUNT FLOAT, 
NEXT_DUE_DATE DATE,
BOM_BKT_LLM VARCHAR(255),
BOM_BKT_LM VARCHAR(255),
ALLOCATION_LLM VARCHAR(255),
ON_OFF_BOOK VARCHAR(255)
ALLOCATION
PENAL_ORIGINAL FLOAT, -- is it same as PENAL_AMOUNT_OUTSTANDING
ALLOCATION VARCHAR(255),
ALLOCATION_DATE DATE,
BOM_BUCKET VARCHAR(255), 
DAY1_ALLOCATION VARCHAR(255),
ALLOCATION_CHANNEL VARCHAR(255),
AGENCY_CODE VARCHAR(255),
NPA_STAGEID_NEW VARCHAR(255),
DAILY_DATE DATE,
ROW_HASH VARCHAR AS SHA2(UPPER(ARRAY_TO_STRING([LOAN_NO,CUSTOMER_ID,LOAN_EFFECTIVE_RATE,LAST_RECIEVED_DATE,LPP,PRE_EMI,CBC_DUE,OTHER_CHARGES_DUE,PENAL_AMOUNT_OUTSTANDING,LAST_RECEIPT_AMOUNT,OVERDUE_PRINCIPAL,OVERDUE_INTEREST,TOTAL_DUE,CHEQUE_IN_TRANSIT_AMT,CHEQUE_IN_TRANSIT_COUNT,TOTAL_POS,SCHEME,ALLOCATION,ALLOCATION_DATE,BOM_BUCKET,DAY1_ALLOCATION,ALLOCATION_CHANNEL,AGENCY_CODE,NPA_STAGEID_NEW], ''|'')), 256), -- need to adjust depending on columns if they need to  removed
START_TIMESTAMP TIMESTAMP,
END_TIMESTAMP TIMESTAMP,
CURRENT_FLAG BOOLEAN
	);
	

	CREATE OR REPLACE TEMPORARY TABLE DISHA_MART_ANALYTICS.COLLECTION_MART.LOAD_DELIQUENCY_MART
	(
LOAN_NO VARCHAR(255)
LOAN_BRANCH VARCHAR(255),
SCHEME VARCHAR(255),
CUSTOMER_ID VARCHAR(255),
UNIQUE_CUSTOMER INTEGER,
UNIQUE_CUSTOMER_FLAG_BUCKET VARCHAR(255),
CUSTOMER_NAME VARCHAR(255),
TOTAL_NO_OF_INSTALLMENT INTEGER, -- Tenure Month
MORATORIUM INTEGER,
TOTAL_BILLED_INSTALLMENT_NO FLOAT,
TOTAL_RECEIV_INSTALLMENT FLOAT,
REMAINING_TENURE FLOAT,
OVERDUE_INSTALLMENT_COUNT FLOAT, -- no_of_od_emi
OVERDUE_PRE_EMI_COUNT FLOAT,
TOTAL_DUE FLOAT,
LPP FLOAT,
PRE_EMI FLOAT,
CBC_DUE FLOAT,
OTHER_CHARGES_DUE FLOAT,
PENAL_AMOUNT_OUTSTANDING FLOAT,
TOTAL_POS FLOAT,
CR FLOAT,
DPD INTEGER,
OP_DPD VARCHAR(255),
COLLX_BKT VARCHAR(255),
BUCKET_HEAD VARCHAR(255),
CYCLE VARCHAR(255),
CURRENT_DPD_SCALE VARCHAR(255),
OP_DPD_SCALE VARCHAR(255),
CURRENT_STATUS VARCHAR(255),
RF_CASES VARCHAR(255),
CURRENT_MONTH_INSTALLMENT FLOAT,
CURRENT_MONTH_INSTALLMENT_DUE_DATE DATE,
LOAN_AMOUNT FLOAT, -- Same as SANCTION_AMOUNT
LAST_RECEIVED_DATE DATE,
LAST_RECEIPT_AMOUNT FLOAT,
BOOKING_DATE DATE,
FIRST_EMI_DATE DATE,
LAST_EMI_DATE DATE,
CYCLE_DATE INTEGER,
REPO_FLAG VARCHAR(255),
OVERDUE_PRINCIPAL FLOAT,
OVERDUE_INTEREST FLOAT,
EMI_PATTERN VARCHAR(255),
BOOKING_DATE DATE,
CHEQUE_IN_TRANSIT_AMT FLOAT,
CHEQUE_IN_TRANSIT_COUNT FLOAT,
DISBURSAL_STATUS VARCHAR(255),
LOAN_STATUS VARCHAR(255),
LOAN_PRODUCT VARCHAR(255),
LOAN_EFFECTIVE_RATE FLOAT,
EMI_PEMI VARCHAR(255),
FILE_EXTRACT_DATE DATE,
BUSINESS_DATE DATE,
INSTALLMENT_MODE VARCHAR(255),
LOAN_SANCTION_DATE DATE,
LAST_DISBURMENT_DATE DATE,
BALANCE_TENURE_MONTH INTEGER,
NET_LTV INTEGER,
NPA_STAGEID INTEGER,
EMI_FREQUENCY VARCHAR(255),
EMI_AMOUNT FLOAT
EMI_OVERDUE_AMOUNT  FLOAT,
EXCESS_BALANCE FLOAT,
FUTURE_PRINCIPAL FLOAT,
ROID INTEGER, -- need to join with hierarchy
RO_NAME  VARCHAR(255),-- need to join with hierarchy
NEXT_EMI_AMOUNT FLOAT, 
NEXT_DUE_DATE DATE,
BOM_BKT_LLM VARCHAR(255),
BOM_BKT_LM VARCHAR(255),
ALLOCATION_LLM VARCHAR(255),
ON_OFF_BOOK VARCHAR(255)
ALLOCATION
PENAL_ORIGINAL FLOAT, -- is it same as PENAL_AMOUNT_OUTSTANDING
ALLOCATION VARCHAR(255),
ALLOCATION_DATE DATE,
BOM_BUCKET VARCHAR(255), 
DAY1_ALLOCATION VARCHAR(255),
ALLOCATION_CHANNEL VARCHAR(255),
AGENCY_CODE VARCHAR(255),
NPA_STAGEID_NEW VARCHAR(255),
	)
	AS
	SELECT 
	DISTINCT
	LOAN_NO,
	LOAN_BRANCH,
	SCHEME,
	CUSTOMER_ID,
	UNIQUE_CUSTOMER,
	UNIQUE_CUSTOMER_FLAG_BUCKET,
	CUSTOMER_NAME,
	TOTAL_NO_OF_INSTALLMENT,
	MORATORIUM,
	TOTAL_BILLED_INSTALLMENT_NO,
	TOTAL_RECEIV_INSTALLMENT,
	(TOTAL_NO_OF_INSTALLMENT - TOTAL_BILLED_INSTALLMENT_NO) AS REMAINING_TENURE,
	OVERDUE_INSTALLMENT_COUNT,
	OVERDUE_PRE_EMI_COUNT,
	TOTAL_DUE,
	LPP,
	PRE_EMI,
	CBC_DUE,
	OTHER_CHARGES_DUE,
	(LPP + PRE_EMI + CBC_DUE + OTHER_CHARGES_DUE) AS PENAL_AMOUNT_OUTSTANDING
	TOTAL_POS,
	(TOTAL_POS/10000000) AS CR,
	DPD,
	OP_DPD,
	COLLX_BKT,
	BUCKET_HEAD,
	CYCLE,
	CURRENT_DPD_SCALE,
	OP_DPD_SCALE,
	CURRENT_STATUS,
	RF_CASES,
	CURRENT_MONTH_INSTALLMENT,
	CURRENT_MONTH_INSTALLMENT_DUE_DATE,
	LOAN_AMOUNT,
	LAST_RECEIVED_DATE,
	LAST_RECEIPT_AMOUNT,
	BOOKING_DATE,
	FIRST_EMI_DATE,
	LAST_EMI_DATE,
	CYCLE_DATE,
	REPO_FLAG,
	OVERDUE_PRINCIPAL,
	OVERDUE_INTEREST,
	EMI_PATTERN,
	BOOKING_DATE,
	CHEQUE_IN_TRANSIT_AMT,
	CHEQUE_IN_TRANSIT_COUNT,
	DISBURSAL_STATUS,
	LOAN_STATUS,
	LOAN_PRODUCT,
	LOAN_EFFECTIVE_RATE,
	EMI_PEMI,
	FILE_EXTRACT_DATE,
	BUSINESS_DATE,
	INSTALLMENT_MODE,
	LOAN_SANCTION_DATE,
	LAST_DISBURMENT_DATE,
	BALANCE_TENURE_MONTH,
	NET_LTV,
	NPA_STAGEID,
	EMI_FREQUENCY,
	EMI_AMOUNT,
	EMI_OVERDUE_AMOUNT,
	EXCESS_BALANCE,
	FUTURE_PRINCIPAL,
	ROID,
	RO_NAME,
	NEXT_EMI_AMOUNT,
	NEXT_DUE_DATE,
	BOM_BKT_LLM,
	BOM_BKT_LM,
	ALLOCATION_LLM,
	ON_OFF_BOOK,
	ALLOCATION,
	PENAL_ORIGINAL,
	ALLOCATION,
	ALLOCATION_DATE,
	BOM_BUCKET,
	DAY1_ALLOCATION,
	ALLOCATION_CHANNEL,
	AGENCY_CODE,
	NPA_STAGEID_NEW
FROM(
Select 
	TRIM(cd.LOAN_NO),
	TRIM(cd.LOAN_BRANCH),
	TRIM(cd.SCHEME),
	TRIM(ccd.CUST_ID_FLEX),
	CASE WHEN COUNT(TRIM(cd.LOAN_NO)) = 1 then 1
	ELSE 0 
	END AS UNIQUE, -- need to apply join and group by customerIDCUSTOMER_NAME
	TRIM(cd.TOTAL_NO_OF_INSTALLMENT),
	TRIM(cd.MORATORIUM),
	TRIM(cd.TOTAL_BILLED_INSTALLMENT_NO),
	TRIM(cd.TOTAL_RECEIV_INSTALLMENT),
	cd.OVERDUE_PRE_EMI_COUNT,
	cd.TOTAL_DUE,
	cd.LPP,
	cd.PRE_EMI,
	cd.CBC_DUE,
	cd.OTHER_CHARGES_DUE,
	cd.DPD,
	


		








	LOAN_NUMBER,
	DATE(PROCESS_DATE) AS PROCESS_DATE,
	CLOSURE_AMT,
	CLOSURE_LOAN_COUNT,
	PAYMENT_LOAN_COUNT,
	PREPAYMENT_AMT,
	(CLOSURE_AMT * LOAN_FINAL_RATE) AS CLOSURE_SUM,
	(PREPAYMENT_AMT * LOAN_FINAL_RATE) AS PAYMENT_SUM,
	CATEGORY1_CLOSURE_PP,
	CATEGORY2_CLOSURE_PP,
	DATE(CLOSURE_DATE) AS CLOSURE_DATE,
	CLOSURE_TYPE,
	PMT_TYPE,
	DATE(PMT_DATE) AS PMT_DATE,
	OVERALL_AMT
	FROM(
		SELECT
		TRIM(PC.LOAN_NO) AS LOAN_NUMBER,
		CASE WHEN PC.CATEGORY1_CLOSURE_PP=''CLOSURE'' AND PC.CATEGORY2_CLOSURE_PP NOT IN  (''7.CANCELLATION'',''6.SARFAESI'') THEN AT1.ARREAR_AMT_PAID ELSE 0 END AS CLOSURE_AMT,
		CASE WHEN (CASE WHEN PC.TRANSACTION_CODE_MNEMONIC IN (1083)  AND PC.CATEGORY1_CLOSURE_PP=''CLOSURE'' AND PC.	CATEGORY2_CLOSURE_PP NOT IN  (''7.CANCELLATION'',''6.SARFAESI'') THEN AT1.REPAY_DATE END) IS NOT NULL 
			THEN 1 ELSE 0 END AS CLOSURE_LOAN_COUNT,
		CASE WHEN (CASE WHEN PC.TRANSACTION_CODE_MNEMONIC IN (1082,1404) 
			AND  PC.CATEGORY1_CLOSURE_PP=''PMT'' THEN AT1.REPAY_DATE END) IS NOT NULL 
			THEN 1 ELSE 0 END AS PAYMENT_LOAN_COUNT,
		CASE WHEN PC.CATEGORY1_CLOSURE_PP=''PMT'' THEN AT1.ARREAR_AMT_PAID ELSE 0 END AS PREPAYMENT_AMT,
		PC.CATEGORY1_CLOSURE_PP,
		PC.CATEGORY2_CLOSURE_PP,
		CASE WHEN PC.TRANSACTION_CODE_MNEMONIC IN (1083)  AND PC.CATEGORY1_CLOSURE_PP=''CLOSURE'' AND PC.CATEGORY2_CLOSURE_PP NOT IN  (''7.CANCELLATION'',''6.SARFAESI'') THEN AT1.REPAY_DATE END AS CLOSURE_DATE,
		CASE WHEN PC.TRANSACTION_CODE_MNEMONIC IN (1083)  THEN PC.TRANSACTION_CODE_MNEMONIC ELSE NULL END AS CLOSURE_TYPE,
		CASE WHEN PC.TRANSACTION_CODE_MNEMONIC IN (1082,1404)   THEN PC.TRANSACTION_CODE_MNEMONIC ELSE NULL END AS PMT_TYPE,
		CASE WHEN PC.TRANSACTION_CODE_MNEMONIC IN (1082,1404) AND  PC.CATEGORY1_CLOSURE_PP=''PMT'' THEN AT1.REPAY_DATE END AS PMT_DATE,
		LAD.LOAN_FINAL_RATE,
		PC.PROCESS_DATE ,
		PC.OVERALL_AMT
		FROM (SELECT * FROM DISHA_MART_ANALYTICS.CREDIT_RISK_MART.TEMP_LN_X_PAYMENT_CHRGS 
		QUALIFY ROW_NUMBER() OVER (PARTITION BY  TRIM(LOAN_NO) ,DATE(PROCESS_DATE),CATEGORY1_CLOSURE_PP ORDER BY UNREALISED_PAYMENT DESC,CATEGORY2_CLOSURE_PP DESC)=1)PC 
		LEFT JOIN (SELECT TRIM(LOAN_NO) AS LOAN_NO,DATE(REPAY_DATE)  AS REPAY_DATE,SUM(ARREAR_AMT_PAID) AS ARREAR_AMT_PAID FROM DISHA_L2_CURATED.BASE_MODEL_DATA.PAYMENT_DETAILS WHERE ARREAR_TYPE =''R'' AND ACTIVATION_FLAG=1 GROUP BY TRIM(LOAN_NO) ,DATE(REPAY_DATE))  AT1 
		ON TRIM(PC.LOAN_NO) = AT1.LOAN_NO AND DATE(PC.PROCESS_DATE) = AT1.REPAY_DATE
		LEFT JOIN (SELECT * FROM DISHA_L2_CURATED.BASE_MODEL_DATA.LOAN_ACCOUNT_DETAILS WHERE  ACTIVATION_FLAG=1) LAD
		ON TRIM(PC.LOAN_NO)=TRIM(LAD.LOAN_NO)
		)PF1;

    -- Count total rows in prefinal table
    SELECT COUNT(*) INTO :TOTAL_ROWS_IN_PREFINAL
    FROM DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART_PREFINAL;

    -- Check for duplicates with details
    WITH DUPLICATE_CHECK AS (
        SELECT 
            LOAN_NUMBER, 
            PROCESS_DATE, 
            CATEGORY1_CLOSURE_PP, 
            COUNT(*) AS RECORD_COUNT
        FROM DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART_PREFINAL
        GROUP BY LOAN_NUMBER, PROCESS_DATE, CATEGORY1_CLOSURE_PP
        HAVING COUNT(*) > 1
    )
    SELECT COUNT(*) INTO :DUPLICATE_COUNT
    FROM DUPLICATE_CHECK;

    -- If duplicates exist, return detailed error
    IF (DUPLICATE_COUNT > 0) THEN
          SELECT CONCAT(
            ''===== DATA LOADING FAILED =====
'',
            ''Total Rows in Prefinal: '', :TOTAL_ROWS_IN_PREFINAL, ''
'',
            ''Duplicate Rows Found: '', :DUPLICATE_COUNT, ''
'',
            ''ERROR: Unable to load data due to duplicate entries for LOAN_NUMBER,PROCESS_DATE,CATEGORY1_CLOSURE_PP combination.'',''
''
        ) INTO :FINAL_OUTPUT;
        RETURN FINAL_OUTPUT;
    ELSE

        -- Perform MERGE operation with tracking
        MERGE INTO DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART T
        USING DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART_PREFINAL S
        ON T.LOAN_NUMBER = S.LOAN_NUMBER
            AND T.PROCESS_DATE = S.PROCESS_DATE
            AND T.CATEGORY1_CLOSURE_PP = S.CATEGORY1_CLOSURE_PP
            AND T.CURRENT_FLAG = TRUE
        WHEN MATCHED 
        AND SHA2(UPPER(ARRAY_TO_STRING([
        S.LOAN_NUMBER,
        S.PROCESS_DATE,
        S.CLOSURE_AMT,
        S.CLOSURE_LOAN_COUNT,
        S.PAYMENT_LOAN_COUNT,
        S.PREPAYMENT_AMT,
        S.CLOSURE_SUM,
        S.PAYMENT_SUM,
        S.CATEGORY1_CLOSURE_PP,
        S.CATEGORY2_CLOSURE_PP,
        S.CLOSURE_DATE,
        S.CLOSURE_TYPE,
        S.PMT_TYPE,
        S.PMT_DATE,
        S.OVERALL_AMT
        ], ''|'')), 256) <> T.ROW_HASH
        THEN UPDATE SET 
            CURRENT_FLAG = FALSE,
            END_TIMESTAMP = :CURR_TIME
        WHEN NOT MATCHED THEN 
        INSERT (
        LOAN_NUMBER,
        PROCESS_DATE,
        CLOSURE_AMT,
        CLOSURE_LOAN_COUNT,
        PAYMENT_LOAN_COUNT,
        PREPAYMENT_AMT,
        CLOSURE_SUM,
        PAYMENT_SUM,
        CATEGORY1_CLOSURE_PP,
        CATEGORY2_CLOSURE_PP,
        CLOSURE_DATE,
        CLOSURE_TYPE,
        PMT_TYPE,
        PMT_DATE,
        OVERALL_AMT,
        DAILY_DATE,
        START_TIMESTAMP,
        END_TIMESTAMP,
        CURRENT_FLAG
        )
        VALUES(
        S.LOAN_NUMBER,
        S.PROCESS_DATE,
        S.CLOSURE_AMT,
        S.CLOSURE_LOAN_COUNT,
        S.PAYMENT_LOAN_COUNT,
        S.PREPAYMENT_AMT,
        S.CLOSURE_SUM,
        S.PAYMENT_SUM,
        S.CATEGORY1_CLOSURE_PP,
        S.CATEGORY2_CLOSURE_PP,
        S.CLOSURE_DATE,
        S.CLOSURE_TYPE,
        S.PMT_TYPE,
        S.PMT_DATE,
        S.OVERALL_AMT,
        CURRENT_DATE(),
        :CURR_TIME, 
        NULL, 
        TRUE
        )
        ;

        -- Count rows affected
         ROWS_INSERTED := (SELECT COUNT(*) FROM DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART WHERE CURRENT_FLAG=1 and START_TIMESTAMP=:CURR_TIME);
         ROWS_UPDATED := (SELECT COUNT(*) FROM DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART WHERE CURRENT_FLAG=0 and END_TIMESTAMP=:CURR_TIME);
         ROWS_UNCHANGED := :TOTAL_ROWS_IN_PREFINAL - (:ROWS_INSERTED + :ROWS_UPDATED);
		 
		 INSERT INTO DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART (
			LOAN_NUMBER,
			PROCESS_DATE,
			CLOSURE_AMT,
			CLOSURE_LOAN_COUNT,
			PAYMENT_LOAN_COUNT,
			PREPAYMENT_AMT,
			CLOSURE_SUM,
			PAYMENT_SUM,
			CATEGORY1_CLOSURE_PP,
			CATEGORY2_CLOSURE_PP,
			CLOSURE_DATE,
			CLOSURE_TYPE,
			PMT_TYPE,
			PMT_DATE,
			DAILY_DATE,
			START_TIMESTAMP,
			END_TIMESTAMP,
			CURRENT_FLAG
			)
			SELECT
			S.LOAN_NUMBER,
			S.PROCESS_DATE,
			S.CLOSURE_AMT,
			S.CLOSURE_LOAN_COUNT,
			S.PAYMENT_LOAN_COUNT,
			S.PREPAYMENT_AMT,
			S.CLOSURE_SUM,
			S.PAYMENT_SUM,
			S.CATEGORY1_CLOSURE_PP,
			S.CATEGORY2_CLOSURE_PP,
			S.CLOSURE_DATE,
			S.CLOSURE_TYPE,
			S.PMT_TYPE,
			S.PMT_DATE,
			CURRENT_DATE(),
			:CURR_TIME, 
			NULL, 
			TRUE
			FROM DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART_PREFINAL S
			JOIN DISHA_MART_ANALYTICS.CREDIT_RISK_MART.PAYMENT_AND_CLOSURE_MART T
				ON T.LOAN_NUMBER = S.LOAN_NUMBER
				AND T.PROCESS_DATE = S.PROCESS_DATE
				AND T.CATEGORY1_CLOSURE_PP = S.CATEGORY1_CLOSURE_PP
				AND T.CURRENT_FLAG = FALSE
				AND T.END_TIMESTAMP = :CURR_TIME;
				

        -- Prepare detailed output
          SELECT CONCAT(
            ''===== DATA LOADING REPORT =====
'',
            ''Process Timestamp: '', :CURR_TIME, ''
'',
            ''Total Rows in Prefinal: '', :TOTAL_ROWS_IN_PREFINAL, ''
'',
            ''Rows Inserted: '', :ROWS_INSERTED, ''
'',
            ''Rows Updated: '', :ROWS_UPDATED, ''
'',
            ''Rows Unchanged: '', :ROWS_UNCHANGED, ''

'',
            ''

'',
            ''Status: SUCCESSFULLY LOADED DATA INTO PAYMENT_AND_CLOSURE_MART''
        ) INTO :FINAL_OUTPUT;

        RETURN FINAL_OUTPUT;
    END IF;
EXCEPTION
    WHEN OTHER THEN
        -- Capture any unexpected errors
         ERROR_MESSAGE := SQLERRM;
        
        -- Prepare error output
          SELECT CONCAT(
            ''===== DATA LOADING FAILED =====
'',
            ''Error Timestamp: '', :CURR_TIME, ''
'',
            ''Total Rows in Prefinal: '', :TOTAL_ROWS_IN_PREFINAL, ''
'',
            ''ERROR MESSAGE: '', :ERROR_MESSAGE, ''
'',
            ''Status: UNEXPECTED ERROR DURING LOADING''
        ) INTO :FINAL_OUTPUT;

        RETURN FINAL_OUTPUT;
END';